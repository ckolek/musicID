#!/usr/bin/env python
__author__ = 'jfeinberg_Deniz'

import sys, getopt, os, subprocess, io

from sys import argv
from wave.waveData import WaveData
from wave.waveDataReader import WaveDataReader
from WaveDataComparator import WaveDataComparator
from util.exceptions import InvalidFormatError
from os import listdir
from os.path import isfile, join

"""
Main class that runs all of the components of the dan audio matching program.
"""
class dan:
    def run(self):
        # Check the arguments input from the command line
        checkInput(self)

        # If the input check is OK, read the wave data.
        # The WaveDataReader checks the file's header and will throw an
        # error if the file was labelled .wav but not actually a wav file.
        try:
            wave1 = read_wave_data(file1)
        except InvalidFormatError:
            print ("ERROR: " + os.path.basename(file1) + " is not a supported"
                   " format\n")
            sys.exit(2)

        try:
            wave2 = read_wave_data(file2)
        except InvalidFormatError:
            print ("ERROR: " + os.path.basename(file2) + " is not a supported"
                   " format\n")
            sys.exit(2)

        # Once the files are read, compare them
        comp = WaveDataComparator(wave1, wave2)
        if comp.areMatching():
            print "MATCH " + file1 + " " + file2
        else:
            print "NO MATCH"

        return 0

# Check if the command line argument(s) are acceptable
def checkInput(self):
    # Declare variables to hold the files that are passed in to global scope
    global file1
    global file2
    file1 = None
    file2 = None

    # Parse command line input
    try:
        # Get everything on the command line after the file name
        # getopt returns the options and arguments as two separate arrays
        opts, args = getopt.getopt(argv[1:], 'hf:', ['help'])

        # If the user does not use the proper syntax, tell them they
        # have entered the wrong input and exit
        if len(opts) < 2:
            print ("ERROR: Incorrect input. Input two file paths with the -f"
                   " option front of each file\n")
            sys.exit(2)

        # If no options are provided notify the user
        if not opts:
            print ('ERROR: No tags provided. Please precede each file name with'
                   ' the -f tag\n')
    # If there is an error, print it out and exit
    except getopt.GetoptError as err:
        print str(err)
        sys.exit(2)

    # Loop through the resulting options and arguments
    for o, a in opts:
        # If the user asks for help, print out the usage function to tell them
        # what to do
        if o in ('-h', '--help'):
            usage()
        # If the user passes in a file location
        elif o in ('-f'):
            # If the file location is valid
            if os.path.exists(a):
                # If it is the first file, assign the argument to the file1
                # variable
                if file1 is None:
                    file1 = a
                # Otherwise, assign the argument to the file2 variable
                else:
                    file2 = a
            # Otherwise, tell the user that the file at the location does not
            # exist
            else:
                print "ERROR: File location does not exist\n"
                sys.exit(2)
        # If the user passes in a directory
        elif o in ('-d'):
            # If the directory location is valid
            if os.path.exists(a):
                # If it is the first directory
                if file1 is None:
                    # Grab only the files in the first directory
                    onlyfiles0 = [ f for f in listdir(a) if isfile(join(a,f)) ]
                    #TODO: Assign file1 based on some directory 2 counter
                    file1 = onlyfiles0[0]
                # If it is the second directory
                else:
                    # Grab only the files in the second directory
                    onlyfiles1 = [ f for f in listdir(a) if isfile(join(a,f)) ]
                    #TODO: Assign file2 based on some fft complete counter
                    file2 = onlyfiles1[0]
        else:
            sys.exit(2)


# The usage information returned when -h parameter is given
def usage():
    print "\nThis is the CLI for the dan audio matcher program\n"
    print 'Usage: ' + argv[0] + ' -f <file1> -f <file2>'

# Return the wav dat
def read_wave_data(file_name):
    try:
        dot_index = file_name.find('.')
    except ValueError as e:
        print "ERROR: " + file_name + " is not a supported format\n"
        sys.exit(2)

    extension = file_name[dot_index:]
    file_output = subprocess.check_output(['file', file_name])

    if extension == "wav":
        if file_output.index('WAVE') < 0:
            print "ERROR: " + file_name + " is not a supported format\n"
            sys.exit(2)

        istream = io.open(file_name, 'rb')
    elif extension == "mp3":
        if file_output.index('MPEG') < 0 or file_output.index('layer III') < 0:
            print "ERROR: " + file_name + " is not a supported format\n"
            sys.exit(2)

        p = subprocess.Popen(['./course/cs4500f14/bin/lame',
                              '--decode',
                              file_name,
                              '-'],
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)

        istream = p.stdout

    with WaveDataReader(istream) as reader:
        return reader.read()

# Call main run function
if __name__ == "__main__":
    _dan = dan()

    status = _dan.run()

    sys.exit(status)