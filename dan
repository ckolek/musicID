#!/usr/bin/env python
__author__ = 'jfeinberg_Deniz'

import sys, getopt, os, subprocess, io

from sys import argv
from wave.waveData import WaveData
from wave.waveDataReader import WaveDataReader
from WaveDataComparator import WaveDataComparator
from util.exceptions import InvalidFormatError
from os import listdir
from os.path import isfile, join

"""
Main class that runs all of the components of the dan audio matching program.
"""
class dan:
    def run(self):
        self.setUp()

        # Check the arguments input from the command line
        checkInput(self)

        if set1dir:
            dirComp()
        else:
            fileComp()

        self.tearDown()

    # set up temporary directory
    def setUp(self):
        if os.path.exists('/tmp/musicId'):
            subprocess.check_call(['rm', '-r', '/tmp/musicId'])

        os.mkdir('/tmp/musicId')

    # clean up temporary directory
    def tearDown(self):
        subprocess.call(['rm', '-r', '/tmp/musicId'])

# Check if the command line argument(s) are acceptable
def checkInput(self):
    # Declare variables to hold the files that are passed in to global scope
    global set1
    global set2
    # Used to determine if either of the files are directories. Initially set to false
    global set1dir
    global set2dir
    set1dir = False
    set2dir = False
    set1 = None
    set2 = None


    # Parse command line input
    try:
        # Get everything on the command line after the file name
        # getopt returns the options and arguments as two separate arrays
        opts, args = getopt.getopt(argv[1:], 'hf:d:', ['help'])

        # If the user does not use the proper syntax, tell them they
        # have entered the wrong input and exit
        if len(opts) < 2:
            print ("ERROR: Incorrect input. Input two file paths with the -f"
                   " option front of each file\n")
            sys.exit(2)

        # If no options are provided notify the user
        if not opts:
            print ('ERROR: No tags provided. Please precede each file name with'
                   ' the -f tag\n')
    # If there is an error, print it out and exit
    except getopt.GetoptError as err:
        print str(err)
        sys.exit(2)

    # Loop through the resulting options and arguments
    for o, a in opts:
        # If the user asks for help, print out the usage function to tell them
        # what to do
        if o in ('-h', '--help'):
            usage()
        # If the user passes in a file location
        elif o in '-f':
            # If the file location is valid
            if os.path.exists(a):
                # Error checking to ensure that the file location actually is a file
                if os.path.isfile(a):
                    # If the file is equal to the first file passed in
                    # assign it to set 1. Set1 check is there in case both files
                    # being compared are the same
                    if a == opts[0][1] and set1 is None:
                        set1 = a
                    # Otherwise, assign the argument to the set2 variable
                    else:
                        set2 = a
                # Print out an error stating that a file was not correctly passed in
                else:
                    print ('ERROR: Provided a directory as input when a file was'
                            ' expected ' + a)
                    sys.exit(2)
            # Otherwise, tell the user that the file at the location does not
            # exist
            else:
                print "ERROR: File location does not exist\n"
                sys.exit(2)
        # If the user passes in a directory
        elif o in '-d':
            # If the directory location is valid
            if os.path.exists(a):
                # Error checking to ensure that the directory location actually has
                # a directory
                if os.path.isdir(a):
                    # If the directory is the first directory passed in, assign the
                    # argument to set1 and make the set1dir variable true. set1 is None
                    # is there in case two files being compared are the same
                    if a == opts[0][1] and set1 is None:
                        set1dir = True
                        # Grab only the files in the first directory
                        set1 = [ join(a, f) for f in listdir(a) if isfile(join(a, f))]
                    # Otherwise, assign the argument to the set2 variable and
                    # make the set2dir variable true
                    else:
                        # Grab only the files in the second directory
                        set2dir = True
                        set2 = [ join(a, f) for f in listdir(a) if isfile(join(a, f))]
                # Otherwise, print out an error stating a directory was not correctly
                else:
                    print ('ERROR: Provided a file as input when a directory was'
                            ' expected ' + a)
                    sys.exit(2)
            else:
                # Otherwise, tell the user that the directory at the location does not
                # exist
                print "ERROR: Directory location does not exist\n"
                sys.exit(2)
        else:
            sys.exit(2)



# Checks the file's header and will throw an
# error if the file was labelled .wav but not actually a wav file.
def readFile(file1):
    # Try except to read the file data
    try:
        return read_wave_data(file1)
        #TODO: need to put function for getting MP3 data here too
    except InvalidFormatError:
        print ("ERROR: " + os.path.basename(file1) + " is not a supported"
               " format\n")
        sys.exit(2)

# Basic comparison function. Call the waveDataComparator class to
# determine equality and print the result
def compare(file1, file2):
    comp = WaveDataComparator(file1, file2)
    if comp.areMatching():
        print "MATCH " + file1 + " " + file2
    else:
        print "NO MATCH"

    return 0

# Read format function. This is called when the first parameter is a file
def fileComp():
    # Get the data from the first file
    wave1 = readFile(set1)
    # If the second set is a directory, get the data for every file
    # in the directory and compare it against the first file
    if set2dir:
        for f in set2:
            wave2 = readFile(f)

            compare(wave1, wave2)
    # If not, both parameters are files. Get the data for the second file
    # and compare
    else:
        wave2 = readFile(set2)
        compare(wave1, wave2)


# Read format function. This is called when the first parameter is a directory
def dirComp():
    # For every file in the first directory, get the data and compare against
    # the second parameter
    for f in set1:
        wave1 = readFile(f)

        # If the second set is also a directory, get the data from every file
        # and compare against the file at the current index in the first set
        if set2dir:
            for g in set2:
                wave2 = readFile(g)
                compare(wave1, wave2)
        # If not, compare every file in the first set against the data from
        # the second file
        else:
            wave2 = readFile(set2)
            compare(wave1, wave2)


# The usage information returned when -h parameter is given
def usage():
    print "\nThis is the CLI for the dan audio matcher program\n"
    print 'Usage: ' + argv[0] + ' -f <set1> -f <set2>'

# Return the wav data
def read_wave_data(file_name):
    try:
        dot_index = file_name.index('.')
    except ValueError as e:
        print "ERROR: " + file_name + " is not a supported format\n"
        sys.exit(2)

    extension = file_name[dot_index + 1:]
    file_info = get_file_info(file_name)

    if extension == "wav":
        if file_info.find('WAVE') < 0:
            print "ERROR: " + file_name + " is not a supported format\n"
            sys.exit(2)
    elif extension == "mp3":
        if file_info.find('MPEG') < 0 or file_info.find('layer III') < 0:
            print "ERROR: " + file_name + " is not a supported format\n"
            sys.exit(2)

        new_file_name = '/tmp/musicId/' + os.path.basename(file_name)
        new_file_name = new_file_name[:-4] + '.wav'
        
        devnull = open('/dev/null', 'w')

        subprocess.check_call(['/course/cs4500f14/bin/lame',
                               '--decode',
                               file_name,
                               new_file_name],
                              stdout=devnull,
                              stderr=devnull)

        file_name = new_file_name

    with WaveDataReader.open(file_name) as reader:
        return reader.read()

def get_file_info(file_name):
    """
    :return: the string returned when calling unix 'file' command on given file
     name, recursively searching symbolic links if necessary
    """

    file_info = subprocess.check_output(['file', file_name])

    sym_link_index = file_info.find('symbolic link to `')

    if sym_link_index >= 0:
        parent_directory = os.path.join(file_name, os.pardir)

        name_index = sym_link_index + 18
        end_name_index = file_info.index("'", name_index)

        name = file_info[name_index:end_name_index]
        name = os.path.abspath(os.path.join(parent_directory, name))

        return get_file_info(name)

    return file_info

# Call main run function
if __name__ == "__main__":
    _dan = dan()

    status = _dan.run()

    sys.exit(status)
