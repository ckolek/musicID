__author__ = 'Mike_Deniz'

import Segmenter
import numpy as np
from numpy.fft import fft, fftfreq
import matplotlib.mlab as ml
import matplotlib.pyplot as plt
from scipy.ndimage.filters import maximum_filter
from scipy.ndimage.morphology import (generate_binary_structure,
                                      iterate_structure, binary_erosion)
import hashlib
from operator import itemgetter
import os.path
import sys

IDX_FREQ_I = 0
IDX_TIME_J = 1

'''
CREDIT TO:
Dejavu library
   github.com/worldveil/dejavu
'''

# Sampling rate, related to the Nyquist conditions, which affects
# the range frequencies we can detect.
DEFAULT_FS = 44100

# Size of the FFT window, affects frequency granularity
DEFAULT_WINDOW_SIZE = 4096

# Ratio by which each sequential window overlaps the last and the
# next window. Higher overlap will allow a higher granularity of offset
# matching, but potentially more fingerprints.
DEFAULT_OVERLAP_RATIO = 0.5

# Degree to which a fingerprint can be paired with its neighbours;
# higher will cause more fingerprints, but potentially better accuracy.
DEFAULT_FAN_VALUE = 15

# Minimum amplitude in spectrogram in order to be considered a peak.
# This can be raised to reduce number of fingerprints, but can negatively
# affect accuracy.
DEFAULT_AMP_MIN = 10

# Number of cells around an amplitude peak in the spectrogram in order
# to consider it a spectral peak. Higher values mean less fingerprints and
# faster matching, but can potentially affect accuracy.
PEAK_NEIGHBORHOOD_SIZE = 20

# Thresholds on how close or far fingerprints can be in time in order
# to be paired as a fingerprint. If your max is too low, higher values of
# DEFAULT_FAN_VALUE may not perform as expected.
MIN_HASH_TIME_DELTA = 0
MAX_HASH_TIME_DELTA = 200

# If True, will sort peaks temporally for fingerprinting;
# not sorting will cut down number of fingerprints, but potentially
# affect performance.
PEAK_SORT = True

# Number of bits to throw away from the front of the SHA1 hash in the
# fingerprint calculation. The more you throw away, the less storage, but
# potentially higher collisions and misclassification's when identifying songs.
FINGERPRINT_REDUCTION = 20

# samples in a given segment
SAMPLES_PER_SEGMENT = Segmenter.SAMPLES_PER_SEGMENT

# Ranges of frequencies for audio bands we want the relative power of
RANGES = [16, 32, 512, 2048, 8192, 16384]

# Frequencies generated by the FFT on an array of size 8192
FREQS = list(fftfreq(8192, 1.0/DEFAULT_FS))[0:SAMPLES_PER_SEGMENT/2]

# the array indicies for the ranges of the frequencies above
BANDS = []
t = 0
for x in range(len(FREQS)):
    if t == len(RANGES):
        break
    if FREQS[x] > RANGES[t]:
        BANDS.append(x)
        t += 1


# the sequence of numbers used in computing LSH values for fingerprints
WEIGHTS = [-2, 5, -1, 2, -4]

# Limit the number of fingerprint kept in memory
LSH_LIMIT = 2250000
# Each fingerprint is 80 bytes long, with average length songs (~3mins) at
# 2.5s segments that'd fingerprints would be 5760 bytes per song. At a 200MB
# memory limit, we could concievably keep the fingerprints for 34,700 songs in
# memory, which would be 2,498,400 fingerprints (at 2.5 segment lengths).
# To be conservative and account for other things we might be keeping in memory,
# the LSH_LIMIT value has been set to 2.25 million.


writtenToDisk = []

class WaveDataComparator:
    def __init__(self, set1, set2):
        self.set1 = set1
        self.set2 = set2


    # Compare function: computes 2 LSH tables for given fingerprints
    # and compares the fingerprints
    def compare(self):

        # two LSH tables to be used for comparisons
        lsh1 = {}
        lsh2 = {}

        lshCnt = 0
        limitHitp = False

        # get fingerprints for files in set 1, and add them
        # to lsh1
        for x in self.set1:
            x = self.makeFingerprints(x)
            for f in x:
                hx = self.hashFunct(f)

                print sys.getsizeof(f)

                # Check if the fingerprint limit has been reached
                if lshCnt > LSH_LIMIT:
                    limitHitp = True
                    # If so, write the remaining fingerprints to disk
                    self.writeToDisk(hx, f)

                if limitHitp is False:
                    if hx in lsh1 and (limitHitp is False):
                        lsh1[hx].append(f)
                    else:
                        lsh1[hx] = [f]
                    lshCnt += 1  # Increment shared lsh counter

        # repeat above process for set 2 and lsh2
        for x in self.set2:
            x = self.makeFingerprints(x)
            for f in x:
                hx = self.hashFunct(f)

                # Check if the fingerprint limit has been reached
                if lshCnt > LSH_LIMIT:
                    limitHitp = True
                    # Write the remaining fingerprints to disk
                    self.writeToDisk(hx, f)

                if limitHitp is False:
                    if hx in lsh2 and (limitHitp is False):
                        lsh2[hx].append(f)
                    else:
                        lsh2[hx] = [f]
                    lshCnt += 1  # Increment shared lsh counter

        #FIXME: after making LSH tables implement comparisons


    # this function returns a list of fingerprints for a given file
    def makeFingerprints(self, file):

        # Get a list of segments to be fingerprinted
        segList = Segmenter.segment_data(file[0])

        # array where fingerprints will be stored
        fprints = []

        # Go through this list of segments, converting each segment
        # in place into its corresponding fingerprint
        # conversions will be to a tuple of the form:
        # (fingerprint, time offset of that fingerprint, file name)
        for n in range(len(segList)):
            fprints.append((self.fingerprint(segList[n][0]), segList[n][1], file[1]))

        return fprints

    # compute a fingerprint for a given range of samples
    def fingerprint(self, samples, bands = BANDS):

        # take an fft over our samples and convert the complex values
        # to their magnitudes (only take positive frequencies
        samples = list(fft(samples))
        samples = map(abs, samples[0:SAMPLES_PER_SEGMENT/2])

        # our final fprint is a list corresponding to 'powers' of
        # certain bands of frequencies
        fprint = []
        for x in range(len(bands)-1):
            fprint.append(sum(samples[bands[x]:bands[x+1]]))

        # next, sort the samples and get the strongest frequencies
        # present in each group of samples
        top5 = sorted(samples)[0:5]
        for x in top5:
            fprint.append(FREQS[samples.index(x)])


        return fprint


    # a hash function for our LSH tables, takes a fingerprint
    # and returns a hashvalue for that fingerprint
    def hashFunct(self, fprint):

        # the hash function will be a sequence of weights times
        # the band strengths plus the average of the strongest frequencies
        val = 0
        lw = len(WEIGHTS)
        for x in range(lw):
            val += WEIGHTS[x] + fprint[0][x]

        val += sum(fprint[0][lw:2*lw])/lw

        return int(val)

    # Write the given fingerprint to disk, naming the file after the hashkey
    # Append the hashkey to a list of things we've written to disk
    def writeToDisk(self, key, fingerprint):
        # Get our current directory
        cur_dir = os.path.dirname(os.path.abspath(__file__))
        # Set our destination directory /tmp/
        dest_dir = os.path.join(cur_dir, 'tmp')
        # Try to make the tmp dir
        try:
            os.makedirs(dest_dir)
        except OSError:
            pass  # Already exists
        # Create our target path
        path = os.path.join(dest_dir, str(key)+'.txt')
        # Write fingerprint to disk
        with open(path, 'a') as stream:  # Open file in append mode
            stream.write(str(fingerprint))

        # Add hashkey to LOthings We've Written
        writtenToDisk.append(key)
        stream.close()

    # Given a hashkey, try to find the corresponding fingerprint txt file
    def readFromDisk(self, key):
        try:
            f = open('tmp/'+str(key)+".txt", 'r') # Open file in read mode
            return f.read()
        except (OSError, IOError) as e:
            return  # File not found